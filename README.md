# Algorithmic Complexity

[Source](https://github.com/makersacademy/course/tree/master/algorithmic_complexity)

A short course covering time complexity, why it matters, and how can it help us think differently about our code to write programs that scale (and possibly impress interviewers).

## Kickoff

We’ll introduce the context for the course, and talk about why we will use a timing framework.

## Workshop 1: Algorithm design

This workshop is also part of week 10, so a number of you will already have had it.
No prerequisite, but having a working timing framework is recommended.

## Workshop 2: Memory and arrays

We will explore how memory work and use that knowledge to make our algorithms faster.
Prerequisite: Having created your timing framework, and written your own version of shuffle and reverse.

## Workshop 3: More data structures

We will design a data structure to solve the efficiency issues found in arrays, and explore the trade offs that are made in data structures.
Prerequisite: Having created your timing framework, and written your own version of shuffle, reverse, find duplicates and most frequent words.

## Workshop 4: Smarter algorithms - Sorting

We will look at a common way to make very fast algorithms, and use that knowledge to create the most efficient sorting algorithms.
Prerequisite: Having created your timing framework, and written your own version of shuffle, reverse, find duplicates, most frequent words, sorting 0s and 1s. Before the workshop, I’ll ask you to think about your own sorting algorithms (how would you sort a deck of cards?)
